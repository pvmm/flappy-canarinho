#!/bin/env python3

from os import path, getcwd
from ninepatch import Ninepatch

# Carregar ambiente virtual
if path.exists(path.join(getcwd(), 'venv')):
	activate_this = path.join(getcwd(), 'venv/bin/activate_this.py')
	with open(activate_this) as file_:
		exec(file_.read(), dict(__file__ = activate_this))

# Inicialização
import pygame
from pygame.time import get_ticks
from pygame import Rect
from PIL import Image
import random

pygame.init()
tela = pygame.display.set_mode((700, 497))
pygame.display.set_caption('Canarinho Pistola')
relogio = pygame.time.Clock()

# Variáveis e constantes
PRETO = (0, 0, 0)
G = 0.001; X = 0; Y = 1
local = getcwd()
IMPULSO_INICIAL = -0.002
CANARINHO = pygame.image.load(path.join(local, 'jogador-pequeno.png')).convert_alpha()
OBSTACULO = Ninepatch(path.join(local, 'obstaculo.9.png'))
POSICAO_INICIAL = (100, 200)
MARGEM_INFERIOR = 200
ABERTURA = 40
LARGURA = 80
MARGEM = 50
terminado = False

#
# Funções úteis.
#

def pulou(jogador):
	jogador['impulso'] = -0.010
	jogador['velocidade'] = 0


def atualiza_altura(jogador, t):
	# Equações de movimento, entrem em ação!
	g = G + jogador['impulso'] # somatório das forças
	v = jogador['velocidade'] + (g * t); # v = vo + at
	h = jogador['posicao'][Y] + (v * t) + (0.5 * g * t * t); # s = s0 + vt + 0.5 * gt^2

	jogador['impulso'] = 0
	jogador['posicao'][Y] = h
	jogador['velocidade'] = v


def criar_jogador():
	return {
		'imagem': CANARINHO,
		'tamanho': CANARINHO.get_size(),
		'posicao': list(POSICAO_INICIAL),
		'velocidade': 0,
		'impulso': IMPULSO_INICIAL,
	}


def atualiza_obstaculo(obstaculo, t):
	obstaculo['posicao1'][X] -= obstaculo['velocidade'] * t
	obstaculo['posicao2'][X] -= obstaculo['velocidade'] * t


def criar_obstaculo():
	comprimento, altura = tela.get_size()
	começo_buraco = random.randint(50, altura - ABERTURA)
	fim_buraco = altura - começo_buraco - ABERTURA
	obstaculo1 = OBSTACULO.render(LARGURA, começo_buraco)
	obstaculo2 = OBSTACULO.render(LARGURA, fim_buraco + MARGEM)

	return {
		'imagem1': pygame.image.fromstring(obstaculo1.tobytes(), obstaculo1.size, obstaculo1.mode),
		'tamanho1': (LARGURA, começo_buraco),
		'posicao1': [comprimento, -MARGEM],
		'imagem2': pygame.image.fromstring(obstaculo2.tobytes(), obstaculo2.size, obstaculo2.mode),
		'tamanho2': (LARGURA, fim_buraco),
		'posicao2': [comprimento, começo_buraco + ABERTURA + MARGEM],
		'velocidade' : 0.1,
	}


# Preparação inicial
pygame.time.wait(500)
jogador = criar_jogador()
obstaculo = criar_obstaculo()
antes = get_ticks()

while not terminado:
	areas = []

	# Atualiza temporização.
	agora = get_ticks()
	duração = agora - antes

	# Limpa região da tela usada no frame anterior.
	areas.append(Rect(jogador['posicao'], jogador['tamanho']))
	pygame.draw.rect(tela, PRETO, areas[0])

	# Limpa região da tela dos obstáculos
	area2 = Rect(obstaculo['posicao1'], obstaculo['tamanho1'])
	area3 = Rect(obstaculo['posicao2'], obstaculo['tamanho2'])
	pygame.draw.rect(tela, PRETO, area2)
	pygame.draw.rect(tela, PRETO, area3)

	# Atualiza posição dos obstáculos
	atualiza_obstaculo(obstaculo, duração)
	tela.blit(obstaculo['imagem1'], obstaculo['posicao1'])
	tela.blit(obstaculo['imagem2'], obstaculo['posicao2'])
	area4 = Rect(obstaculo['posicao1'], obstaculo['tamanho1'])
	area5 = Rect(obstaculo['posicao2'], obstaculo['tamanho2'])

	# Atualiza posição do jogador na tela.
	atualiza_altura(jogador, duração)

	# Processa posição e recria jogador que caiu fora da tela.
	if jogador['posicao'][Y] - MARGEM_INFERIOR > tela.get_size()[Y]:
		jogador = criar_jogador()
		print('caiu!')

	# Desenha jogador e atualiza região desenhada da tela.
	areas.append(Rect(jogador['posicao'], jogador['tamanho']))
	tela.blit(jogador['imagem'], jogador['posicao'])
	pygame.display.update(areas)

	# Processa teclado
	for event in pygame.event.get(pygame.KEYUP) :

		# Pula com a tecla de espaço.
		if jogador['posicao'][Y] > 0:
			if event.key == pygame.K_SPACE:
				pulou(jogador)

		# Sai do programa ao teclar ESC.
		if event.key == pygame.K_ESCAPE:
			terminado = True

	# Detecta evento de fechar janela.
	if pygame.event.get(pygame.QUIT):
		exit()

	# 30 frames por segundo.
	relogio.tick(30)
	antes = agora

